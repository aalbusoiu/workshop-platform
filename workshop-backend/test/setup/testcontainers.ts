import { spawn } from 'node:child_process';
import { PostgreSqlContainer } from '@testcontainers/postgresql';
import type { StartedPostgreSqlContainer } from '@testcontainers/postgresql';

export class TestDatabaseContainer {
  private static container: StartedPostgreSqlContainer | null = null;
  private static databaseUrl: string | null = null;
  private static startPromise: Promise<void> | null = null;
  private static migrationsApplied = false;
  private static readonly START_TIMEOUT_MS = 120_000;

  /**
   * Boots a Postgres Testcontainers instance once per test run, exposes its DATABASE_URL
   * to the process, and executes Prisma migrations so the schema mirrors production
   * before any test touches the database. Subsequent calls no-op to reuse the same container.
   */
static async start(): Promise<void> {
  if (this.databaseUrl) {
    return;
  }

  if (!this.startPromise) {
    this.startPromise = (async () => {
      let container: StartedPostgreSqlContainer | null = null;

      try {
        container = await new Promise<StartedPostgreSqlContainer>((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error('Postgres container did not start within 30s'));
        }, this.START_TIMEOUT_MS);

        new PostgreSqlContainer('postgres:16-alpine')
            .withDatabase('workshop_test')
            .withUsername('postgres')
            .withPassword('postgres')
            .withExposedPorts(5432)
            .start()
            .then((started) => {
            clearTimeout(timer);
            resolve(started);
            })
            .catch((error) => {
            clearTimeout(timer);
            reject(error);
            });
        });
        const host = container.getHost();
        const port = container.getMappedPort(5432);
        const url = `postgresql://postgres:postgres@${host}:${port}/workshop_test?schema=public`;

        process.env.DATABASE_URL = url;
        this.container = container;
        this.databaseUrl = url;

        if (!this.migrationsApplied) {
          await this.applyMigrations(url);
          this.migrationsApplied = true;
        }
      } catch (error) {
        if (container) {
          await container.stop();
        }
        throw error;
      }
    })().finally(() => {
      this.startPromise = null;
    });
  }

  await this.startPromise;
}

  /**
   * Returns the connection string generated by start(); throws an informative error
   * if the container has not been launched yet to catch missing global setup early.
   */
  static getDatabaseUrl(): string {
    if (!this.databaseUrl) {
      throw new Error('Test database has not been started. Call TestDatabaseContainer.start() first.');
    }
    return this.databaseUrl;
  }

  /**
   * Tears down the running Postgres container during global teardown,
   * releasing Docker resources and clearing cached references so the next run
   * starts from a clean slate.
   */
    static async stop(): Promise<void> {
    if (!this.container) {
        return;
    }

    await this.container.stop();
    this.container = null;
    this.databaseUrl = null;
    this.migrationsApplied = false;
    }

  private static async applyMigrations(databaseUrl: string): Promise<void> {
    const prismaCli = require.resolve('prisma/build/index.js'); // Node entrypoint for the Prisma CLI

    await new Promise<void>((resolve, reject) => {
      const child = spawn(
        process.execPath, // Use the current Node binary to execute Prisma's JS entry
        [prismaCli, 'migrate', 'deploy', '--schema=prisma/schema.prisma'],
        {
          env: { ...process.env, DATABASE_URL: databaseUrl },
          stdio: 'inherit',
        },
      );

      child.on('exit', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`prisma migrate deploy exited with code ${code ?? 0}`));
        }
      });

      child.on('error', reject);
    });
  }
}
